outputname,description,type,sqlquery,plot
procedureinfo,Identified Oracle internal packages dependency within Code,procedureinfo,"SELECT a.referenced_owner, REFERENCED_NAME, COUNT(1) FROM all_dependencies a WHERE a.owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND A.REFERENCED_NAME NOT IN ('STANDARD', 'DBMS_STANDARD') AND a.referenced_type != 'NON-EXISTENT' and a.referenced_type not in('TABLE', 'SEQUENCE', 'TYPE') AND a.referenced_owner IN ('SYS', 'SYSTEM', 'PUBLIC') and a.name <> a.referenced_name AND a.owner = '<<ORACLE_SCHEMA>>' GROUP BY a.referenced_owner, REFERENCED_NAME ORDER BY 3 DESC",GRAPH
procedureinfo,Identified Oracle order of conversion for procedural component,procedureinfo,"SELECT distinct a.referenced_owner, a.referenced_name, referenced_type, count(1) over (partition by a.referenced_name) as refer_count FROM all_dependencies a WHERE a.owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_type != 'NON-EXISTENT' and a.referenced_type not in('TABLE', 'SEQUENCE', 'TYPE') and a.name <> a.referenced_name start with a.owner in ('<<ORACLE_SCHEMA>>') CONNECT BY a.owner = PRIOR a.referenced_owner AND a.name = PRIOR a.referenced_name AND a.type = PRIOR a.referenced_type order by 4 desc",GRAPH_1
FirstConverter,First Candidate procedural code for conversion,FirstConverter,"WITH vw_scoped_objects AS ( SELECT owner, object_name, object_type, regexp_count(uncommented_ddl, CHR(10)) AS lines FROM ( SELECT owner, object_name, object_type, regexp_replace( ddl, '(''.*?''|"".*?"")|/\s*\*.*?\*/\s*|\s*--.*?(?=$|\z)', '\1', 1, 0, 'mn' ) AS uncommented_ddl FROM ( SELECT all_objects.owner, all_objects.object_name, all_objects.object_type, dbms_metadata.get_ddl( CASE all_objects.object_type WHEN 'MATERIALIZED VIEW' THEN 'MATERIALIZED_VIEW' WHEN 'PACKAGE BODY' THEN 'PACKAGE_BODY' WHEN 'TYPE BODY' THEN 'TYPE_BODY' ELSE all_objects.object_type END, all_objects.object_name, all_objects.owner ) AS ddl FROM all_objects WHERE all_objects.owner IN ('<<ORACLE_SCHEMA>>') AND all_objects.status = 'VALID' AND all_objects.object_type NOT IN ( 'SEQUENCE', 'INDEX', 'PACKAGE BODY', 'LOB', 'TABLE PARTITION', 'JOB', 'TYPE BODY' ) AND generated = 'N' ) ) ORDER BY 1, CASE object_type WHEN 'TABLE' THEN 1 WHEN 'TYPE' THEN 2 WHEN 'VIEW' THEN 3 WHEN 'MATERIALIZED VIEW' THEN 4 WHEN 'TRIGGER' THEN 5 WHEN 'FUNCTION' THEN 6 WHEN 'PROCEDURE' THEN 7 WHEN 'PACKAGE' THEN 8 ELSE 100 END ), DEPENDENCY AS ( SELECT /*+ materialize*/ a.owner, a.name, a.type, a.referenced_owner, a.referenced_name, a.referenced_type, level as lv FROM all_dependencies a WHERE a.owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_type != 'NON-EXISTENT' and a.referenced_type not in ('TABLE', 'SEQUENCE') START WITH a.owner = '<<ORACLE_SCHEMA>>' AND ( a.type IN ( 'TRIGGER', 'TYPE', 'PROCEDURE', 'FUNCTION', 'PACKAGE', 'VIEW' ) ) CONNECT BY a.owner = PRIOR a.referenced_owner AND a.name = PRIOR a.referenced_name AND a.type = PRIOR a.referenced_type order by lv desc ) select distinct 'First-Candidate-Conversion', referenced_owner, referenced_type, referenced_name, lines, 0 as LVL from DEPENDENCY, vw_scoped_objects where DEPENDENCY.owner = vw_scoped_objects.owner and DEPENDENCY.referenced_name = vw_scoped_objects.object_name and DEPENDENCY.referenced_type = vw_scoped_objects.object_type and referenced_owner || '_' || referenced_type || '_' || referenced_name not in ( select owner || '_' || type || '_' || name from DEPENDENCY ) order by CASE referenced_type WHEN 'TYPE' THEN 3 WHEN 'VIEW' THEN 4 WHEN 'MATERIALIZED VIEW' THEN 5 WHEN 'TRIGGER' THEN 2 WHEN 'FUNCTION' THEN 7 WHEN 'PROCEDURE' THEN 9 WHEN 'PACKAGE' THEN 11 ELSE 100 END asc",NA
summary,Oracle Migration Overview - Summary,summary,"WITH VW_SCOPED_OBJECTS AS ( SELECT owner, object_name, object_type, regexp_count(uncommented_ddl, CHR(10)) AS lines FROM ( SELECT owner, object_name, object_type, regexp_replace( ddl, '(''.*?''|"".*?"")|/\s*\*.*?\*/\s*|\s*--.*?(?=$|\z)', '\1', 1, 0, 'mn' ) AS uncommented_ddl FROM ( SELECT all_objects.owner, all_objects.object_name, all_objects.object_type, dbms_metadata.get_ddl( case all_objects.object_type when 'MATERIALIZED VIEW' then 'MATERIALIZED_VIEW' when 'PACKAGE BODY' then 'PACKAGE_BODY' when 'TYPE BODY' then 'TYPE_BODY' ELSE all_objects.object_type END, all_objects.object_name, all_objects.owner ) AS ddl FROM all_objects WHERE all_objects.owner IN ('<<ORACLE_SCHEMA>>') and all_objects.status = 'VALID' AND all_objects.OBJECT_TYPE NOT IN ( 'SEQUENCE', 'INDEX', 'PACKAGE BODY', 'LOB', 'TABLE PARTITION', 'JOB', 'TYPE BODY' ) and GENERATED = 'N' ) ) ORDER BY 1, CASE OBJECT_TYPE WHEN 'TABLE' THEN 1 WHEN 'TYPE' THEN 2 WHEN 'VIEW' THEN 3 WHEN 'MATERIALIZED VIEW' THEN 4 WHEN 'TRIGGER' THEN 5 WHEN 'FUNCTION' THEN 6 WHEN 'PROCEDURE' THEN 7 WHEN 'PACKAGE' THEN 8 ELSE 100 END ) SELECT OWNER, OBJECT_TYPE, COUNT(1) CNT_OBJ, SUM(LINES) AS LOC FROM VW_SCOPED_OBJECTS GROUP BY OWNER, OBJECT_TYPE",NA
tableinfo,"Database Table sizing information with LOB \ Partition \ PK information",tableinfo,"WITH INPUT AS ( SELECT UPPER('<<ORACLE_SCHEMA>>') AS SCHEMANAME FROM DUAL ), ALIAS1 AS ( SELECT /*+ MATERIALIZE */ alias1.owner, alias1.table_name, ( SELECT 'Y' FROM dba_lobs where dba_lobs.owner = upper(alias1.owner) and dba_lobs.table_name = alias1.table_name and rownum = 1 ) ""LOB"", ( SELECT 'Y' FROM all_constraints cons, all_cons_columns cols WHERE cons.owner = alias1.owner and cols.table_name = alias1.table_name AND cons.constraint_type = 'P' AND cons.constraint_name = cols.constraint_name AND cons.owner = cols.owner and rownum = 1 ) as ""PK"", round(SUM(""Total Size Gigs""), 4) ""SIZEGIGS"", TRUNC(SUM(lobsize)) AS ""LOBSIZE"", TRUNC(SUM(nonlobsize)) AS ""NONLOBSIZE"", ( SELECT num_rows FROM dba_tables WHERE dba_tables.owner = alias1.owner AND dba_tables.table_name = alias1.table_name ) AS num_rows_approx, ( SELECT avg_row_len FROM dba_tables WHERE dba_tables.owner = alias1.owner AND dba_tables.table_name = alias1.table_name ) AS avg_row_len, round( (SUM(""Total Size Gigs"") * 1024 * 1024) /( SELECT CASE WHEN num_rows = 0 THEN 1 ELSE num_rows END FROM dba_tables WHERE dba_tables.owner = alias1.owner AND dba_tables.table_name = alias1.table_name ), 2 ) AS avg_rows_size_approx_kb, nvl( ( SELECT partitioned FROM dba_tables WHERE dba_tables.owner = alias1.owner AND dba_tables.table_name = alias1.table_name ), 'NO' ) AS ""PARTITION?"", ( SELECT COUNT(1) FROM dba_tab_columns WHERE dba_tab_columns.owner = alias1.owner AND dba_tab_columns.table_name = alias1.table_name AND data_type IN ('CLOB', 'NCLOB', 'BLOB') AND nullable = 'N' ) not_null_lob_constraint FROM ( SELECT owner, ( CASE WHEN table_name IS NULL THEN tab_name ELSE table_name END ) table_name, round(SUM(""Total Size Gigs""), 2) AS ""Total Size Gigs"", round( ( SELECT SUM( CASE WHEN segment_type IN('LOBSEGMENT', 'LOB PARTITION', 'LOBINDEX') THEN bytes END ) / 1024 / 1024 / 1024 FROM dba_segments ds WHERE ds.segment_name = tab_name AND ds.owner = owner ), 4 ) AS lobsize, round( ( SELECT SUM( CASE WHEN segment_type NOT IN('LOBSEGMENT', 'LOB PARTITION', 'LOBINDEX') THEN bytes END ) / 1024 / 1024 / 1024 FROM dba_segments ds WHERE ds.segment_name = tab_name AND ds.owner = owner ), 4 ) AS nonlobsize FROM ( SELECT size_list.owner, size_list.tab_name, size_list.segment_type, lob_list.table_name, SUM(size_list.""Total Size Gigs"") / 1024 / 1024 / 1024 ""Total Size Gigs"" FROM ( SELECT owner, segment_name, table_name FROM dba_lobs WHERE owner = ( SELECT SCHEMANAME FROM INPUT ) ) lob_list RIGHT OUTER JOIN ( SELECT dba_tables.owner owner, dba_tables.table_name segment_name, dba_tables.table_name AS tab_name, 'N' AS contain_lob, dba_segments.segment_type, SUM(dba_segments.bytes) ""Total Size Gigs"" FROM dba_tables left outer join dba_segments on dba_tables.OWNER = dba_segments.OWNER AND dba_segments.segment_type IN ( 'TABLE SUBPARTITION', 'TABLE PARTITION', 'NESTED TABLE', 'LOB PARTITION', 'LOBSEGMENT', 'TABLE' ) and dba_segments.segment_name not like 'BIN$%' WHERE dba_tables.OWNER = ( SELECT SCHEMANAME FROM INPUT ) GROUP BY dba_tables.owner, dba_tables.table_name, dba_segments.segment_type ) size_list ON lob_list.segment_name = size_list.segment_name AND lob_list.owner = size_list.owner GROUP BY size_list.owner, size_list.segment_type, size_list.tab_name, lob_list.table_name ) GROUP BY owner, tab_name, ( CASE WHEN table_name IS NULL THEN tab_name ELSE table_name END ) ) alias1 GROUP BY alias1.owner, alias1.table_name ORDER BY 4 DESC ) SELECT owner, table_name, nvl(""LOB"", 'N') as ""LOB"", nvl(""PK"", 'N') as ""PK"", nvl(""SIZEGIGS"", 0) as ""SIZEGIGS"", nvl(""LOBSIZE"", 0) as ""LOBSIZE"", nvl(""NONLOBSIZE"", 0) as ""NONLOBSIZE"", nvl(num_rows_approx, 0) as num_rows_approx, nvl(avg_row_len, 0) as avg_row_len, nvl(avg_rows_size_approx_kb, 0) as avg_rows_size_approx_kb, NVL(""PARTITION?"", 'N') as ""PARTITION?"", not_null_lob_constraint, DECODE( SUM(""SIZEGIGS"") OVER (), 0, 0, trunc((""SIZEGIGS"" / SUM(""SIZEGIGS"") OVER ()) * 100) ) as ""TOP%"", DECODE( TRUNC(SUM(""LOBSIZE"") OVER ()), 0, 0, trunc((""LOBSIZE"" / SUM(""LOBSIZE"") OVER ()) * 100) ) ""LOB%"", DECODE( SUM(""NONLOBSIZE"") OVER (), 0, 0, trunc((""NONLOBSIZE"" / SUM(""NONLOBSIZE"") OVER ()) * 100) ) ""NONLOB%"", ROW_NUMBER() OVER ( ORDER BY ""SIZEGIGS"" DESC NULLS LAST ) ""RN_TOTALSIZE"", ROW_NUMBER() OVER ( ORDER BY ""LOBSIZE"" DESC NULLS LAST ) ""RN_LOBSIZESIZE"", ROW_NUMBER() OVER ( ORDER BY ""NONLOBSIZE"" DESC NULLS LAST ) ""RN_NONLOBSIZE"" FROM ALIAS1",GRAPH
tableinfo,List of Oracle Schema,tableinfo,"select username as userSchema from dba_users where username not in ('DBA_ADM','SYSTEM','CTXSYS','DBSNMP','EXFSYS','LBACSYS','MDSYS','MGMT_VIEW','OLAPSYS','ORDDATA','OWBSYS','ORDPLUGINS','ORDSYS','OUTLN','SI_INFORMTN_SCHEMA','SYS','SYSMAN','WK_TEST','WKSYS','WKPROXY','WMSYS','XDB','APEX_PUBLIC_USER','DIP','FLOWS_020100','FLOWS_030000','FLOWS_040100','FLOWS_010600','FLOWS_FILES','MDDATA','ORACLE_OCM','SPATIAL_CSW_ADMIN_USR','SPATIAL_WFS_ADMIN_USR','XS$NULL','PERFSTAT','SQLTXPLAIN','DMSYS','TSMSYS','WKSYS','APEX_040000','APEX_040200','DVSYS','OJVMSYS','GSMADMIN_INTERNAL','APPQOSSYS','DVSYS','DVF','AUDSYS','APEX_030200','MGMT_VIEW','ODM','ODM_MTR','TRACESRV','MTMSYS','OWBSYS_AUDIT','WEBSYS','WK_PROXY','OSE$HTTP$ADMIN','AURORA$JIS$UTILITY$','AURORA$ORB$UNAUTHENTICATED','DBMS_PRIVILEGE_CAPTURE','CSMIG','MGDSYS','SDE','DBSFWUSER')",NA
codeconversionplanning,Planned overall code conversion as per Weeks,codeconversionplanning,"WITH INPUT AS ( SELECT '<<ORACLE_SCHEMA>>' AS OWNER, <<NO_OF_WEEK>> NO_OF_WEEK FROM DUAL ), SYNONYM_REFERENCE AS ( SELECT /*+ MATERIALIZE */ DISTINCT owner, object_type, object_name, CASE WHEN object_type = 'SYNONYM' THEN ( SELECT table_owner FROM dba_synonyms WHERE dba_synonyms.owner = dba_objects.owner AND dba_synonyms.synonym_name = dba_objects.object_name ) ELSE NULL END AS synonym_object_owner, CASE WHEN object_type = 'SYNONYM' THEN ( SELECT table_name FROM dba_synonyms WHERE dba_synonyms.owner = dba_objects.owner AND dba_synonyms.synonym_name = dba_objects.object_name ) ELSE NULL END AS synonym_object_name, CASE WHEN object_type = 'SYNONYM' THEN ( SELECT dbj.object_type FROM dba_synonyms, dba_objects dbj WHERE dba_synonyms.owner = dba_objects.owner AND dba_synonyms.synonym_name = dba_objects.object_name AND dbj.owner = table_owner AND dbj.object_name = table_name AND ROWNUM = 1 ) ELSE NULL END AS synonym_object_type FROM dba_objects WHERE owner IN ( SELECT OWNER FROM INPUT ) AND object_type NOT IN ('TABLE', 'INDEX', 'TYPE') ), VW_REF_TRIGGERS as ( SELECT distinct a.owner, a.name, a.TYPE, level as lvl, CASE WHEN a.referenced_type = 'SYNONYM' THEN a.referenced_type ELSE NULL END AS Synonym_Ref, CASE WHEN a.referenced_type = 'SYNONYM' then ( SELECT s.synonym_object_owner FROM SYNONYM_REFERENCE S WHERE S.owner = a.referenced_owner and s.object_name = a.referenced_name ) else a.referenced_owner end referenced_owner, CASE WHEN a.referenced_type = 'SYNONYM' then ( SELECT s.synonym_object_name FROM SYNONYM_REFERENCE S WHERE S.owner = a.referenced_owner and s.object_name = a.referenced_name ) else a.referenced_name end referenced_name, CASE WHEN a.referenced_type = 'SYNONYM' then ( SELECT s.synonym_object_type FROM SYNONYM_REFERENCE S WHERE S.owner = a.referenced_owner and s.object_name = a.referenced_name ) else a.referenced_type end as referenced_type, count(1) over (partition by a.name) as ref_count, count(1) over (partition by a.referenced_name) as refer_count FROM all_dependencies a WHERE a.owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_type != 'NON-EXISTENT' and a.referenced_type not in('TABLE', 'SEQUENCE', 'TYPE') and a.name <> a.referenced_name start with a.owner in ( SELECT OWNER FROM INPUT ) and A.type = 'TRIGGER' CONNECT BY a.owner = PRIOR a.referenced_owner AND a.name = PRIOR a.referenced_name AND a.type = PRIOR a.referenced_type order by a.owner, a.name ), VW_REF_VIEW as ( SELECT distinct a.owner, a.name, a.TYPE, level as lvl, CASE WHEN a.referenced_type = 'SYNONYM' THEN a.referenced_type ELSE NULL END AS Synonym_Ref, CASE WHEN a.referenced_type = 'SYNONYM' then ( SELECT s.synonym_object_owner FROM SYNONYM_REFERENCE S WHERE S.owner = a.referenced_owner and s.object_name = a.referenced_name ) else a.referenced_owner end referenced_owner, CASE WHEN a.referenced_type = 'SYNONYM' then ( SELECT s.synonym_object_name FROM SYNONYM_REFERENCE S WHERE S.owner = a.referenced_owner and s.object_name = a.referenced_name ) else a.referenced_name end referenced_name, CASE WHEN a.referenced_type = 'SYNONYM' then ( SELECT s.synonym_object_type FROM SYNONYM_REFERENCE S WHERE S.owner = a.referenced_owner and s.object_name = a.referenced_name ) else a.referenced_type end as referenced_type, count(1) over (partition by a.name) as ref_count, count(1) over (partition by a.referenced_name) as refer_count FROM all_dependencies a WHERE a.owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_type != 'NON-EXISTENT' and a.referenced_type not in('TABLE', 'SEQUENCE', 'TYPE') and a.name <> a.referenced_name start with a.owner in ( SELECT OWNER FROM INPUT ) and A.type = 'VIEW' CONNECT BY a.owner = PRIOR a.referenced_owner AND a.name = PRIOR a.referenced_name AND a.type = PRIOR a.referenced_type order by a.owner, a.name ), VW_REF_PACKAGE AS ( SELECT DISTINCT a.owner, a.name, a.type, level AS lvl, CASE WHEN a.referenced_type = 'SYNONYM' THEN a.referenced_type ELSE NULL END AS synonym_ref, CASE WHEN a.referenced_type = 'SYNONYM' THEN ( SELECT s.synonym_object_owner FROM SYNONYM_REFERENCE s WHERE s.owner = a.referenced_owner AND s.object_name = a.referenced_name ) ELSE a.referenced_owner END referenced_owner, CASE WHEN a.referenced_type = 'SYNONYM' THEN ( SELECT s.synonym_object_name FROM SYNONYM_REFERENCE s WHERE s.owner = a.referenced_owner AND s.object_name = a.referenced_name ) ELSE a.referenced_name END referenced_name, CASE WHEN a.referenced_type = 'SYNONYM' THEN ( SELECT s.synonym_object_type FROM SYNONYM_REFERENCE s WHERE s.owner = a.referenced_owner AND s.object_name = a.referenced_name ) ELSE a.referenced_type END AS referenced_type, COUNT(1) OVER(PARTITION BY a.name) AS ref_count, COUNT(1) OVER(PARTITION BY a.referenced_name) AS refer_count FROM all_dependencies a WHERE a.owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_type != 'NON-EXISTENT' AND a.referenced_type NOT IN ('TABLE', 'SEQUENCE', 'TYPE') AND a.name <> a.referenced_name START WITH a.owner IN ( SELECT OWNER FROM INPUT ) AND a.type = 'PACKAGE' CONNECT BY a.owner = PRIOR a.referenced_owner AND a.name = PRIOR a.referenced_name AND a.type = PRIOR a.referenced_type ORDER BY a.owner, a.name ), VW_REF_PROCEDURE AS ( SELECT DISTINCT a.owner, a.name, a.type, level AS lvl, CASE WHEN a.referenced_type = 'SYNONYM' THEN a.referenced_type ELSE NULL END AS synonym_ref, CASE WHEN a.referenced_type = 'SYNONYM' THEN ( SELECT s.synonym_object_owner FROM SYNONYM_REFERENCE s WHERE s.owner = a.referenced_owner AND s.object_name = a.referenced_name ) ELSE a.referenced_owner END referenced_owner, CASE WHEN a.referenced_type = 'SYNONYM' THEN ( SELECT s.synonym_object_name FROM SYNONYM_REFERENCE s WHERE s.owner = a.referenced_owner AND s.object_name = a.referenced_name ) ELSE a.referenced_name END referenced_name, CASE WHEN a.referenced_type = 'SYNONYM' THEN ( SELECT s.synonym_object_type FROM SYNONYM_REFERENCE s WHERE s.owner = a.referenced_owner AND s.object_name = a.referenced_name ) ELSE a.referenced_type END AS referenced_type, COUNT(1) OVER(PARTITION BY a.name) AS ref_count, COUNT(1) OVER(PARTITION BY a.referenced_name) AS refer_count FROM all_dependencies a WHERE a.owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_type != 'NON-EXISTENT' AND a.referenced_type NOT IN ('TABLE', 'SEQUENCE', 'TYPE') AND a.name <> a.referenced_name START WITH a.owner IN ( SELECT OWNER FROM INPUT ) AND a.type = 'PROCEDURE' CONNECT BY a.owner = PRIOR a.referenced_owner AND a.name = PRIOR a.referenced_name AND a.type = PRIOR a.referenced_type ORDER BY a.owner, a.name ), VW_REF_FUNCTIONS AS ( SELECT DISTINCT a.owner, a.name, a.type, level AS lvl, CASE WHEN a.referenced_type = 'SYNONYM' THEN a.referenced_type ELSE NULL END AS synonym_ref, CASE WHEN a.referenced_type = 'SYNONYM' THEN ( SELECT s.synonym_object_owner FROM SYNONYM_REFERENCE s WHERE s.owner = a.referenced_owner AND s.object_name = a.referenced_name ) ELSE a.referenced_owner END referenced_owner, CASE WHEN a.referenced_type = 'SYNONYM' THEN ( SELECT s.synonym_object_name FROM SYNONYM_REFERENCE s WHERE s.owner = a.referenced_owner AND s.object_name = a.referenced_name ) ELSE a.referenced_name END referenced_name, CASE WHEN a.referenced_type = 'SYNONYM' THEN ( SELECT s.synonym_object_type FROM SYNONYM_REFERENCE s WHERE s.owner = a.referenced_owner AND s.object_name = a.referenced_name ) ELSE a.referenced_type END AS referenced_type, COUNT(1) OVER(PARTITION BY a.name) AS ref_count, COUNT(1) OVER(PARTITION BY a.referenced_name) AS refer_count FROM all_dependencies a WHERE a.owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_owner NOT IN ('SYS', 'SYSTEM', 'PUBLIC') AND a.referenced_type != 'NON-EXISTENT' AND a.referenced_type NOT IN ('TABLE', 'SEQUENCE', 'TYPE') AND a.name <> a.referenced_name START WITH a.owner IN ( SELECT OWNER FROM INPUT ) AND a.type = 'FUNCTION' CONNECT BY a.owner = PRIOR a.referenced_owner AND a.name = PRIOR a.referenced_name AND a.type = PRIOR a.referenced_type ORDER BY a.owner, a.name ), VW_SCOPED_OBJECTS AS ( SELECT /*+ materialize*/ owner, object_name, object_type, regexp_count(uncommented_ddl, CHR(10)) AS lines FROM ( SELECT owner, object_name, object_type, regexp_replace( ddl, '(''.*?''|"".*?"")|/\s*\*.*?\*/\s*|\s*--.*?(?=$|\z)', '\1', 1, 0, 'mn' ) AS uncommented_ddl FROM ( SELECT all_objects.owner, all_objects.object_name, all_objects.object_type, dbms_metadata.get_ddl( case all_objects.object_type when 'MATERIALIZED VIEW' then 'MATERIALIZED_VIEW' when 'PACKAGE BODY' then 'PACKAGE_BODY' when 'TYPE BODY' then 'TYPE_BODY' ELSE all_objects.object_type END, all_objects.object_name, all_objects.owner ) AS ddl FROM all_objects WHERE all_objects.owner IN ( SELECT OWNER FROM INPUT ) AND all_objects.object_type IN ( 'PACKAGE', 'VIEW', 'FUNCTION', 'PROCEDURE', 'TYPE_BODY', 'TRIGGER', 'MATERIALIZED VIEW' ) ) ) ORDER BY 1, CASE OBJECT_TYPE WHEN 'VIEW' THEN 1 WHEN 'MATERIALIZED VIEW' THEN 2 WHEN 'TRIGGER' THEN 3 WHEN 'FUNCTION' THEN 4 WHEN 'PROCEDURE' THEN 5 WHEN 'PACKAGE' THEN 6 ELSE 100 END ), tbl_trigger_ref AS ( SELECT DISTINCT REFERENCED_OWNER, REFERENCED_NAME, VW_REF_TRIGGERS.REFERENCED_TYPE, REFER_COUNT, VW_SCOPED_OBJECTS.LINES, ROW_NUMBER() OVER ( ORDER BY REFER_COUNT desc ) AS RNK FROM VW_REF_TRIGGERS LEFT OUTER JOIN VW_SCOPED_OBJECTS ON VW_REF_TRIGGERS.REFERENCED_OWNER = VW_SCOPED_OBJECTS.OWNER AND VW_REF_TRIGGERS.REFERENCED_NAME = VW_SCOPED_OBJECTS.OBJECT_NAME AND VW_REF_TRIGGERS.REFERENCED_TYPE = VW_SCOPED_OBJECTS.OBJECT_TYPE ORDER BY REFER_COUNT desc ), tbl_VIEW_ref AS ( SELECT DISTINCT REFERENCED_OWNER, REFERENCED_NAME, VW_REF_VIEW.REFERENCED_TYPE, REFER_COUNT, VW_SCOPED_OBJECTS.LINES, ROW_NUMBER() OVER ( ORDER BY REFER_COUNT desc ) AS RNK FROM VW_REF_VIEW LEFT OUTER JOIN VW_SCOPED_OBJECTS ON VW_REF_VIEW.REFERENCED_OWNER = VW_SCOPED_OBJECTS.OWNER AND VW_REF_VIEW.REFERENCED_NAME = VW_SCOPED_OBJECTS.OBJECT_NAME AND VW_REF_VIEW.REFERENCED_TYPE = VW_SCOPED_OBJECTS.OBJECT_TYPE ORDER BY REFER_COUNT desc ), tbl_PACKAGE_ref AS ( SELECT DISTINCT REFERENCED_OWNER, REFERENCED_NAME, VW_REF_PACKAGE.REFERENCED_TYPE, REFER_COUNT, VW_SCOPED_OBJECTS.LINES, ROW_NUMBER() OVER ( ORDER BY REFER_COUNT desc ) AS RNK FROM VW_REF_PACKAGE LEFT OUTER JOIN VW_SCOPED_OBJECTS ON VW_REF_PACKAGE.REFERENCED_OWNER = VW_SCOPED_OBJECTS.OWNER AND VW_REF_PACKAGE.REFERENCED_NAME = VW_SCOPED_OBJECTS.OBJECT_NAME AND VW_REF_PACKAGE.REFERENCED_TYPE = VW_SCOPED_OBJECTS.OBJECT_TYPE ORDER BY REFER_COUNT desc ), tbl_procedure_ref AS ( SELECT DISTINCT referenced_owner, referenced_name, referenced_type, refer_count, VW_SCOPED_OBJECTS.lines, ROW_NUMBER() OVER ( ORDER BY refer_count desc ) AS RNK FROM VW_REF_PROCEDURE LEFT OUTER JOIN VW_SCOPED_OBJECTS ON vw_ref_procedure.referenced_owner = VW_SCOPED_OBJECTS.owner AND vw_ref_procedure.referenced_name = VW_SCOPED_OBJECTS.object_name AND vw_ref_procedure.referenced_type = VW_SCOPED_OBJECTS.object_type ORDER BY REFER_COUNT desc ), tbl_FUNCTION_ref AS ( SELECT DISTINCT referenced_owner, referenced_name, referenced_type, refer_count, VW_SCOPED_OBJECTS.lines, ROW_NUMBER() OVER ( ORDER BY REFER_COUNT desc ) AS RNK FROM VW_REF_FUNCTIONS LEFT OUTER JOIN VW_SCOPED_OBJECTS ON VW_REF_FUNCTIONS.referenced_owner = VW_SCOPED_OBJECTS.owner AND VW_REF_FUNCTIONS.referenced_name = VW_SCOPED_OBJECTS.object_name AND VW_REF_FUNCTIONS.referenced_type = VW_SCOPED_OBJECTS.object_type ORDER BY REFER_COUNT desc ), ALIAS0 AS ( SELECT TBL_TRIGGER_REF.REFERENCED_OWNER, TBL_TRIGGER_REF.REFERENCED_NAME, TBL_TRIGGER_REF.REFERENCED_TYPE, TBL_TRIGGER_REF.REFER_COUNT, 'TRIGGER-DEPENDENCY' as objtype FROM TBL_TRIGGER_REF UNION ALL SELECT TBL_FUNCTION_REF.REFERENCED_OWNER, TBL_FUNCTION_REF.REFERENCED_NAME, TBL_FUNCTION_REF.REFERENCED_TYPE, TBL_FUNCTION_REF.REFER_COUNT, 'FUNCTION-DEPENDENCY' as objtype FROM TBL_FUNCTION_REF UNION ALL SELECT TBL_PROCEDURE_REF.REFERENCED_OWNER, TBL_PROCEDURE_REF.REFERENCED_NAME, TBL_PROCEDURE_REF.REFERENCED_TYPE, TBL_PROCEDURE_REF.REFER_COUNT, 'PROCEDURE-DEPENDENCY' as objtype FROM TBL_PROCEDURE_REF UNION ALL SELECT TBL_VIEW_REF.REFERENCED_OWNER, TBL_VIEW_REF.REFERENCED_NAME, TBL_VIEW_REF.REFERENCED_TYPE, TBL_VIEW_REF.REFER_COUNT, 'VIEW-DEPENDENCY' as objtype FROM TBL_VIEW_REF UNION ALL SELECT TBL_PACKAGE_REF.REFERENCED_OWNER, TBL_PACKAGE_REF.REFERENCED_NAME, TBL_PACKAGE_REF.REFERENCED_TYPE, TBL_PACKAGE_REF.REFER_COUNT, 'PACKAGE-DEPENDENCY' as objtype FROM TBL_PACKAGE_REF ), ALIAS1 AS ( /*+ materialize */ SELECT distinct OWNER OWNER1, ALIAS0.OBJTYPE, OBJECT_NAME AS TABLENAME, OBJECT_TYPE AS ADDCOL1, LINES AS SIZE1, DENSE_RANK() OVER ( ORDER BY CASE ALIAS0.OBJTYPE WHEN 'PACKAGE-DEPENDENCY' THEN 10 WHEN 'VIEW-DEPENDENCY' THEN 3 WHEN 'PROCEDURE-DEPENDENCY' THEN 8 WHEN 'FUNCTION-DEPENDENCY' THEN 6 WHEN 'TRIGGER-DEPENDENCY' THEN 1 ELSE CASE OBJECT_TYPE WHEN 'VIEW' THEN 4 WHEN 'MATERIALIZED VIEW' THEN 5 WHEN 'TRIGGER' THEN 2 WHEN 'FUNCTION' THEN 7 WHEN 'PROCEDURE' THEN 9 WHEN 'PACKAGE' THEN 11 ELSE 100 END END, REFER_COUNT DESC ) AS ROW_NUM FROM VW_SCOPED_OBJECTS LEFT OUTER JOIN ALIAS0 ON ALIAS0.REFERENCED_OWNER = VW_SCOPED_OBJECTS.OWNER AND ALIAS0.REFERENCED_NAME = VW_SCOPED_OBJECTS.OBJECT_NAME AND ALIAS0.REFERENCED_TYPE = VW_SCOPED_OBJECTS.OBJECT_TYPE ORDER BY 1, CASE ALIAS0.OBJTYPE WHEN 'PACKAGE-DEPENDENCY' THEN 10 WHEN 'VIEW-DEPENDENCY' THEN 3 WHEN 'PROCEDURE-DEPENDENCY' THEN 8 WHEN 'FUNCTION-DEPENDENCY' THEN 6 WHEN 'TRIGGER-DEPENDENCY' THEN 1 ELSE CASE OBJECT_TYPE WHEN 'VIEW' THEN 4 WHEN 'MATERIALIZED VIEW' THEN 5 WHEN 'TRIGGER' THEN 2 WHEN 'FUNCTION' THEN 7 WHEN 'PROCEDURE' THEN 9 WHEN 'PACKAGE' THEN 11 ELSE 100 END END ), ALIAS1a AS ( SELECT ALIAS1.OWNER1, ALIAS1.OBJTYPE, ALIAS1.TABLENAME, ALIAS1.ADDCOL1, ALIAS1.SIZE1, ROW_NUMBER() OVER ( ORDER BY NULL ) ROW_NUM, TRUNC( (SUM(SIZE1) OVER ()) /( SELECT NO_OF_WEEK FROM INPUT ) ) AS WEEK_SIZE FROM ALIAS1 ), ALIAS2 ( OWNER1, TABLENAME, SIZE1, SIZE2, ROW_NUM, GROUP_1, ADDCOL1, WEEK_SIZE ) AS ( SELECT OWNER1, TABLENAME, SIZE1, SIZE1, ROW_NUM, 1 AS GROUP_1, ADDCOL1, WEEK_SIZE FROM ALIAS1a WHERE ROW_NUM = 1 UNION ALL ( SELECT ALIAS1.OWNER1, ALIAS1.TABLENAME, ALIAS1.SIZE1, CASE WHEN (ALIAS1.SIZE1 + ALIAS2.SIZE2 > ALIAS1.WEEK_SIZE) AND ( GROUP_1 != ( SELECT NO_OF_WEEK FROM INPUT ) ) THEN ALIAS1.SIZE1 ELSE ALIAS1.SIZE1 + ALIAS2.SIZE2 END AS SIZE2, ALIAS1.ROW_NUM AS ROW_NUM, CASE WHEN (ALIAS1.SIZE1 + ALIAS2.SIZE2 > ALIAS1.WEEK_SIZE) AND ( GROUP_1 != ( SELECT NO_OF_WEEK FROM INPUT ) ) THEN (GROUP_1 + 1) ELSE GROUP_1 END AS GROUP_1, ALIAS1.ADDCOL1, ALIAS1.WEEK_SIZE FROM ALIAS1a ALIAS1, ALIAS2 WHERE ALIAS2.OWNER1 = ALIAS2.OWNER1 AND ALIAS2.TABLENAME = ALIAS2.TABLENAME AND ALIAS1.ROW_NUM = ALIAS2.ROW_NUM + 1 ) ) SELECT OWNER1 AS OWNER, TABLENAME AS OBJECTNAME, ADDCOL1 AS OBJECTTYPE, SIZE1 AS LOC, MAX(SIZE2) OVER(PARTITION BY GROUP_1) AS DELIVERABLES_CODE, 'WEEK - ' || GROUP_1 as WEEK, ADDCOL1 AS OBJTYPE , GROUP_1 as WEEK_NO FROM ALIAS2 order by ROW_NUM",GRAPH




 

